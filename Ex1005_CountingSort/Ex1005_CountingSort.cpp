#include <iostream>
#include "../shared/Queue.h"
#include <iomanip>

using namespace std;

/*
앞의 기수 정렬에서는 큐를 10개 사용했었습니다. 
큐의 내부에서 메모리 할당(또는 재할당)이 일어날 수 있기 때문에 
데이터가 아주 많은 경우에는 느려질 수도 있습니다. 

이런 사태를 방지하는 한 가지 방법은, 
각각의 큐가 사용할 최대 메모리를 미리 한 번만 할당하면 되지 않을까? 
라고 생각해볼 수 있습니다. 

조금 더 구체적으로는 0으로 끝나는 숫자가 몇 개인지, 
1로 끝나는 숫자가 몇 개인지를 미리 세두는 것입니다. 

여기서 한 걸음 더 나아가서, 어차피 몇 개인지 미리 세어볼거라면 
굳이 큐를 10개나 사용할 필요 없이 배열 하나만 사용하면 되지않을까? 
라는 것이 기본적인 카운팅(counting) 정렬의 아이디어 입니다. 
이때 미리 세어본 개수를 저장하는 count 배열이 추가로 사용되는데 
예시로 설명드리겠습니다.

아래와 같은 배열을 정렬하는 예시를 보겠습니다.


 정렬전:  1    0    2    3    4    2    3    1    2


0이 1개, 1이 2개, 2가 3개, 3이 2개, 4가 1개, 전부 9개라는 것을 
미리 세어서(counting) 아래와 같이 저장할 수 있습니다. 
이때 count 배열의 크기가 10이 아니라 10 + 1 = 11인데요, 
추가된 하나는 아래에서 전체 개수를 저장하게 됩니다.

// 0이 1개, 1이 2개, 2가 3개, 3이 2개, 4가 1개
Count1: 1 2 3 2 1 0 0 0 0 0 0


여기까지는 어렵지 않을 것 같은데요, 이 다음이 이해하기 조금 까다로울 수 있습니다.

위에서 만든 Count1을 왼쪽에서 부터 누적시켜서 Count2를 만듭니다. 
원래 큐 10개 사용할 것을 배열 하나를 나눠 쓰려다 보니 
각각의 영역이 어딘지를 구분하기 위한 용도입니다. 
구체적으로 어떻게 사용하는 지는 아래에 나옵니다.


// 0 이하가 1개, 1 이하가 3개, 2 이하가 6개, 3 이하가 8개, 4 이하가 9개, 
뒷부분은 총 9개라는 의미
Count2 : 1 3 6 8 9 9 9 9 9 9 9

그 다음에 마지막 값부터 하나씩 정렬을 해나갑니다. 2, 1, 3, 2, 4, ... 
순서로 자기 자리를 찾아서 저장합니다.
이때 어디에 저장될 지를 결정할 때 위에서 만든 Count2를 사용합니다.

*/

bool CheckSorted(int* arr, int size)
{
	for (int i = 0; i < size - 1; i++)
	{
		if (arr[i] > arr[i + 1])
			return false;
	}

	return true;
}

void Print(int* arr, int size)
{
	for (int i = 0; i < size; i++)
		cout << setw(4) << arr[i] << " ";
	cout << endl;
}

int GetMax(int arr[], int n)
{
	int mx = arr[0];
	for (int i = 1; i < n; i++)
		if (arr[i] > mx)
			mx = arr[i];
	return mx;
}

int main()
{
	//int arr[] = { 170, 45, 75, 90, 802, 24, 2, 66 };
	int arr[] = { 1, 0, 2, 3, 4, 2, 3, 1, 2 }; // 0이 1개, 1이 2개, 2가 3개, 4가 1개
	int n = sizeof(arr) / sizeof(arr[0]);

	Print(arr, n);

	// Queue<int> queues[10]; // 기본 동기: 큐를 사용하지 말자! 
	int count[10 + 1];        // 각각의 큐에 몇 개가 저장될 것인지 + 마지막 하나는 가장 큰 위치를 표시용
	int* temp = new int[n];   // 임시 저장 메모리, 큐10개가 메모리를 따로따로 사용하는 대신에 하나의 큰 메모리 하나만 사용
	                          // 대신에 큐가 사용할 최대 각각의 크기를 미리 알아야 한다
	

	int m = GetMax(arr, n); // 가장 큰 자리수를 찾기 위해서

	for (int exp = 1; m / exp > 0; exp *= 10)
	{
		for (int i = 0; i < n; i++)
		{
			temp[i] = arr[i]; // 단순 복사
			arr[i] = -1;      // 디버깅 편의
		}

		for (int i = 0; i < 10 + 1; i++)
			count[i] = 0; // 초기화

		for (int i = 0; i < n; i++)
			// queues[(arr[i] / exp) % 10].Enqueue(arr[i]); // 큐에 저장하지 않고
			count[temp[i] / exp % 10] += 1;                 // 각각의 큐에 몇 개가 저장될 것인지만 기록

		cout << "Count1: ";
		Print(count, 11);

		
		int N = 0;
		// 큐 10개가 메모리를 따로따로 갖지 않고 한 줄로 쭉 나열되어 있다면 각각의 큐의 시작 위치는?
		for (int i = 1; i < 10 + 1; i++)
		{
			// TODO: 이 부분을 어렵게 생각하시는 분들이 많네요. 
			//       Count1: 과 Count2: 의 출력을 보고 맞춰보세요.

			count[i] += count[i - 1]; // 여기서 전걸 더해주고 
		}

		cout << "Count2: ";
		Print(count, 11);


		for (int i = n - 1; i >= 0; i--) // Stable sort로 구현하기 위해 역순으로 진행
		{
			cout << temp[i] << endl;

			count[temp[i] / exp % 10] -= 1;
			arr[count[temp[i] / exp % 10]] = temp[i];

			cout << "Count: ";
			Print(arr, n);
		}

		Print(arr, n);
	}

	delete[] temp;

	return 0;
}

/* 이해를 돕기 위해 실제 예상 출력에 추가한 부분이 있습니다.

 정렬전:  1    0    2    3    4    2    3    1    2

 radix:  0    1    2    3    4    5    6    7    8    9
Count1:  1    2    3    2    1    0    0    0    0    0    0   // 0이 1개, 1이 2개, 2가 3개, 3이 2개, 4가 1개

 radix : 0    1    2    3    4    5    6    7    8    9
Count2 : 1    3    6    8    9    9    9    9    9    9    9   // 0 이하가 1개, 1 이하가 3개, 2 이하가 6개, 3 이하가 8개, 4 이하가 9개, 뒷부분은 총 9개라는 의미

기수정렬의 큐 사용에 비유하면,
queues[0]이 인덱스 0에서 1-1 = 0, (0이 1개)
queues[1]이 인덱스 1에서 3-1 = 2, (1이 2개)
queues[2]이 인덱스 3에서 6-1 = 5, (2가 3개)
queues[3]이 인덱스 6에서 8-1 = 7, (3이 2개)
queues[4]이 인덱스 8에서 9-1 = 8, (4가 1개)
에 대응하는 것처럼 생각할 수 있습니다.

2 <- 정렬전 배열의 가장 오른쪽 끝
 Count:    1    3    5    8    9    9    9    9    9    9    9
Output:   -1   -1   -1   -1   -1    2   -1   -1   -1           // <- 2가 자기 위치에 복사됨 (이 위치를 어떻게 찾는지가 포인트입니다)
1
 Count:    1    2    5    8    9    9    9    9    9    9    9
Output:   -1   -1    1   -1   -1    2   -1   -1   -1           // <- 1이 자기 위치에 복사됨
3
 Count:    1    2    5    7    9    9    9    9    9    9    9
Output:   -1   -1    1   -1   -1    2   -1    3   -1           // <- 3이 자기 위치에 복사됨
2
 Count:    1    2    4    7    9    9    9    9    9    9    9
Output:   -1   -1    1   -1    2    2   -1    3   -1
4
 Count:    1    2    4    7    8    9    9    9    9    9    9
Output:   -1   -1    1   -1    2    2   -1    3    4
3
 Count:    1    2    4    6    8    9    9    9    9    9    9
Output:   -1   -1    1   -1    2    2    3    3    4
2
 Count:    1    2    3    6    8    9    9    9    9    9    9
Output:   -1   -1    1    2    2    2    3    3    4
0
 Count:    0    2    3    6    8    9    9    9    9    9    9
Output:    0   -1    1    2    2    2    3    3    4
1
 Count:    0    1    3    6    8    9    9    9    9    9    9
Output:    0    1    1    2    2    2    3    3    4

 정렬후:    0    1    1    2    2    2    3    3    4
*/

/*
170 45 75 90 802 24 2 66
170 90 802 2 24 45 75 66
802 2 24 45 66 170 75 90
2 24 45 66 75 90 170 802
*/